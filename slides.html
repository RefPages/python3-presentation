<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">
      /* Slideshow styles */
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# 10 awesome features of Python that you can't use because you refuse to upgrade to Python 3

---

class: center, middle

# 10 awesome features of Python that you can't use because you refuse to upgrade to Python 3

# or

# Turning it up to 11!

---

class: center, middle

# 10 awesome features of Python that you can't use because you refuse to upgrade to Python 3

# or

# Turning it up to 11!

![](eleven-11.jpg)

---

layout: true

# Feature 1: Advanced unpacking

---


```py
>>> a, b, *rest = range(10)
>>> a
0
>>> b
1
>>> rest
[2, 3, 4, 5, 6, 7, 8, 9]
```

--

`*rest` can go anywhere:

```py
>>> a, *rest, b = range(10)
>>> a
0
>>> b
9
>>> rest
[1, 2, 3, 4, 5, 6, 7, 8]
```

```py
>>> *rest, b = range(10)
>> rest
[0, 1, 2, 3, 4, 5, 6, 7, 8]
>>> b
9
```

---

## Get the first and last lines of a file

```py
>>> with open("using_python_to_profit") as f:
...     first, *_, last = f.readlines()
>>> first
'Step 1: Use Python 3\n'
>>> last
'Step 10: Profit!\n'
```

--

## Refactor your functions

```py
def f(a, b, *args):
    stuff
```

```py
def f(*args):
    a, b, *args = args
    stuff
```

---

layout: true

# Feature 2: Keyword only arguments

---

```py
def f(a, b, *args, option=True):
    ...
```

--

`option` comes *after* `*args`.

--

The only way to access it is to explicitly call `f(a, b, option=True)`

---

No more, "Oops, I accidentally passed too many arguments to the function, and
one of them was swalled by a keyword argument".

```py
def sum(a, b, biteme=False):
    if biteme:
        shutil.rmtree('/')
    else:
        return a + b
```

```
>>> sum(1, 2)
3
>>> sum(1, 2, 3)
<disaster>
```

---

Or, "I reordered the keyword arguments of a function, but something was
implicitly passing in arguments expecting the order"

Stupid example:

```py
def extendto(value, shorter, longer):
    """
    Extend list `shorter` to the length of list `longer` with `value`
    """
    if len(shorter) > len(longer):
        raise ValueError('The `shorter` list is longer than the `longer` list')
    a.extend([value]*(len(longer) - len(shorter)))
```

```py
>>> a = [1, 2]
>>> b = [1, 2, 3, 4, 5]
>>> extendto(10, a, b)
>>> a
[1, 2, 10, 10, 10]
```

--

Hmm, maybe it makes more sense for `longer` to come before `shorter`...

Too bad, you'll break the code.

---

You can use

```py
def extendto(value, *, shorter=None, longer=None):
    """
    Extend list `shorter` to the length of list `longer` with `value`
    """
    if shorter is None or longer is None:
        raise TypeError('`shorter` and `longer` must be specified')
    if len(shorter) > len(longer):
        raise ValueError('The `shorter` list is longer than the `longer` list')
    a.extend([value]*(len(longer) - len(shorter)))
```

Now, `a` and `b` *have* to be passed in as `extendto(10, shorter=a,
longer=b)`.

--

Or if you prefer, `extendto(10, longer=b, shorter=a)`.

---

# Add new keyword arguments without breaking API.

- Python 3 did this in the standard library.

--

- For example, functions in `os` have `follow_symlinks` option.

--

- So you can just use `os.stat(file, follow_symlinks=False)` instead of `os.lstat`.

--

- Lets you do

  ```py
  s = os.stat(file, follow_symlinks=some_condition)
  ```

  instead of

  ```py
  if some_condition:
      s = os.stat(file)
  else:
      s = os.lstat(file)
  ```

--

- But `os.stat(file, some_condition)` doesn't work.

- Keeps you from thinking it's a two-argument function.

---

- In Python 2, you have to use `**kwargs` and do the handling yourself.

--

- Lot's of ugly `option = kwargs.pop(True)` at the top of your functions.

--

- No longer self documenting.

---

layout: true

# Feature 3: Chained exceptions

---

**Situation:** you catch an exception with `except` do something, and then raise a
different exception.

```py
def mycopy(source, dest):
   try:
       shutil.copy2(source, dest)
   except OSError: # We don't have permissions. More on this later
       raise NotImplementedError("automatic sudo injection")
```

**Problem:** You lose the original traceback

```py
>>> mycopy('noway', 'noway2')
>>> mycopy(1, 2)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 5, in mycopy
NotImplementedError: automatic sudo injection
```

--

What happened with the `OSError`?

---

Python 3 shows you the whole chain of exceptions:


```py
mycopy('noway', 'noway2')
Traceback (most recent call last):
  File "<stdin>", line 3, in mycopy
  File "/Users/aaronmeurer/anaconda3/lib/python3.3/shutil.py", line 243, in copy2
    copyfile(src, dst, follow_symlinks=follow_symlinks)
  File "/Users/aaronmeurer/anaconda3/lib/python3.3/shutil.py", line 109, in copyfile
    with open(src, 'rb') as fsrc:
PermissionError: [Errno 13] Permission denied: 'noway'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 5, in mycopy
NotImplementedError: automatic sudo injection
```

--

You can also do this manually using `raise from`

```py
raise exception from e
```

--

```py
>>> raise NotImplementedError from OSError
OSError

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NotImplementedError
```

---

layout: true

# Feature 4: Fine grained OSError subclasses

---

- The code I just showed you is wrong.

- It catches OSError an assumes it is a permission error.

- But OSError can be a lot of things (file not found, is a directory, is not a
  directory, broken pipe, ...)

- You really have to do

```py
import errno
def mycopy(source, dest):
   try:
       shutil.copy2(source, dest)
   except (OSError, IOError) as e:
       if e.errno in [errno.EPERM, errno.EACCES]:
           raise NotImplementedError("automatic sudo injection")
       else:
           raise
```

--

- Wow. That sucks.

---

- Python 3 fixes this by adding a ton of [new exceptions](https://docs.python.org/3.4/library/exceptions.html#os-exceptions).

- You can just do

```py
def mycopy(source, dest):
   try:
       shutil.copy2(source, dest)
   except PermissionError:
       raise NotImplementedError("automatic sudo injection")
```

- (Don't worry, `PermissionError` subclasses from `OSError`. Old code will
  still work).

---

layout: true

# Feature 5: Everything is an iterator

---

- This is the hardest one to sell.

- Iterators exist in Python 2 as well.

- But you have to use them. Don't write `range` or `zip` or `dict.values` or
  ....

---

- If you do...

--

```py
def naivesum(N):
    """
    Naively sum the first N integers
    """
    A = 0
    for i in range(N + 1):
        A += i
    return A
```
--

```py
In [3]: timeit naivesum(1000000)
10 loops, best of 3: 61.4 ms per loop
```

--

```py
In [4]: timeit naivesum(10000000)
1 loops, best of 3: 622 ms per loop
```

--

```py
In [5]: timeit naivesum(100000000)
```

--

<img src="startupdisk.png" width="500">

---

![](badtime.jpg)

---

- Instead write some variant (`xrange`, `itertools.izip`,
  `dict.itervalues`, ...).

- Inconsistant API anyone?

---

- In Python 3, `range`, `zip`, `map`, `dict.values`, etc. are all iterators.

- If you want a list, just wrap the result with `list`.

- Explicit is better than implicit.

- Harder to write code that accidentally uses too much memory, because the
  input was bigger than you expected.

---

layout: true

# Feature 6:


    </textarea>
    <script src="http://gnab.github.io/remark/downloads/remark-0.6.2.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create();
    </script>
  </body>
</html>
